#![allow(non_snake_case)]

fn main()
{
// Константа. Всегда вычисляется на этапе компиляции
// Тип константы всегда указывается явно
// Константы могут быть глобальными
// Константа пишется заглавными буквами. Иначе будет предупреждение от компилятора
const CONST1:u64 = 1000_000;	// Подчёркивание можно использовать для улучшения читаемости

// Неизменяемая переменная. Она может быть вычислена на этапе исполнения
let a = CONST1;


// Вот это делать нельзя. Константа не может приравниваться к неизменяемой переменной
// const const2 = a;


// ----------------------------------------------------------------

// Изменяемая переменная
let mut a = a + 2;

// Вторая переменная a затеняет первую переменную a (здесь это разрешено, в отличие от pony)


a += 1;

// Объявляем переменную типа u64
// Переменная, начинающаяся с "_" не будет генерировать сообщения о том, что она не используется
let _b:u64 = a;


// ----------------------------------------------------------------
// ----------------------------------------------------------------
// МАШИННЫЕ ТИПЫ и иные простые типы

// https://doc.rust-lang.ru/book/ch03-02-data-types.html

// Целые числа со знаком: i8 ... i128, isize
// Без знака u8 ... u128, usize
// Типы size - это максимальное по размеру число в процессорной архитектуре

// Десятичный	98_222
// Шестнадцатеричный	0xff
// Восьмеричный	0o77
// Бинарный	0b1111_0000
// Байтовый (только u8)	b'A'

// Тип можно указать суффиксом
let _a = 1_000_u16;
let _a = 1_00u8;	// Rust не контролирует позицию подчёркивания!!!
let _a = 0o77u8;

let _a:u64 = 128;
let _b:u8  = 8;

// Так нельзя
// let _c = _a + _b; - ошибка приведения типов
// u64 реализует trait std::convert::From<u8>
let _c = _a + u64::from(_b);



// Плавающая точка. По умолчанию - 64 бита.
let _x = 2.0;

// 32 бита
let _x: f32 = 3.0;

// Деление "/", вычисление остатка %

// cannot divide `{float}` by `{integer}`
// 3.0/2

// 3/2 == 1, 3.0/2.0 == 1.5, 3 % 2 == 1, 3 << 2 == 12, 16 >> 2 == 4
println!("3/2 == {}, 3.0/2.0 == {}, 3 % 2 == {}, 3 << 2 == {}, 16 >> 2 == {}", 3/2, 3.0/2.0, 3 % 2, 3 << 2, 16 >> 2);

// 5 ^ 0xA == 15, 5 | 0xA == 15, 5 & 0xA == 0
println!("5 ^ 0xA == {}, 5 | 0xA == {}, 5 & 0xA == {}", 5 ^ 0xA, 5 | 0xA, 5 & 0xA);



// Булевский тип
let _b: bool = false;



// Символ имеет размер 4-ре байта
let _c: char = '₡';

// let _c: char = 0;	- это ошибка приведения типов, в отличие от pony
let _c: char = '\u{0}';	// Скобки фигурные

// let _c: char = '\u{D800}';	это ошибка: unicode escape must not be a surrogate - то есть суррогатные символы UTF-16 здесь не прокатывают - должен быть определён целый символ UTF-32.
let _c: char = '\u{D7FF}';


// -------------------------------------------------------------------------
// -------------------------------- Кортежи --------------------------------

let tup: (i32, f64, u8) = (500, 6.4, 1);
let (_x, _y, _z) = tup;

let _x = tup.0;
let _y = tup.1;
let _z = tup.2;



// -------------------------------- Массивы --------------------------------

// Массивы содержат значения только одного и того же типа
let _a:[u8; 5] = [1, 2, 3, 4, 5];
let _a = [1u8, 2, 3, 4, 5];
let _a = [1, 2, 3, 4, 5];
let _v = _a[0];

// Указанный тип [u8; 5] является типом массива u8 с 5-тью элементами

// Проверки выхода за границы массива
// let _v = _a[100]; Ошибка времени компиляции: index out of bounds: the len is 5 but the index is 100

// Ошибка времени выполнения
// let index = 100;
// let _v = _a[index]; thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 100'


// ----------------------------------------------------------------------------------------
// ---------------------------- Стандартное управление памятью ----------------------------

memoryManagement();

}

fn memoryManagement()
{
	// Здесь мы создаём новую изменяемую строку в куче
	let s = String::from("Привет");

	// Если мы хотим изменять ссылку на строку, то нужно объявить её mutable
	let mut s = s;
	
	// При затенении s другая s выходит из зоны видимости. Rust может её автоматически удалить
	// Однако, Rust видит, что новая s теперь владеет тем участком памяти, которым раньше владела старая переменная s и не будет освобождать память
	// Таким образом, владение (ownership) строкой от одной переменной передаётся к другой

	s.push_str(" всем!");

	// Выведет строку "Привет всем!"
	println!("{}", s);

	// Это не просто копирование ссылки, это "перемещение" ссылки!
	let s2 = s;
	// Здесь мы склонировали весь объект, всю строку целиком, а не только ссылку
	let s3 = s2.clone();

	// Теперь s мы не можем использовать
	// Вот так
	// println!("{}", s);
	// сделать не получится!
	// borrow of moved value - теперь строка "Привет" принадлежит ссылке s2, а ссылка s недействительна
	
	println!("{} {}", s2, s3);
	
	// На простых типах передача владения не происходит: значение переменной просто копируется
	// Простые типы - это те, что не требуют выделения памяти
	let u:u64 = 123456789;
	
	// После вызова функции также происходит передача владения ссылкой
	getOwnerShip(s2, u);

	// Попытка воспользоваться s2 вызовет теперь ошибку! borrow of moved value: `s2`
	// println!("{}", s2);
	// Однако простой тип по-прежнему действителен
	println!("{}", u);
}

fn getOwnerShip(_x: String, _u: u64)
{
}
