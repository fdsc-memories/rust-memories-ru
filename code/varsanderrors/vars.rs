
fn main()
{
// Константа. Всегда вычисляется на этапе компиляции
// Тип константы всегда указывается явно
// Константы могут быть глобальными
// Константа пишется заглавными буквами. Иначе будет предупреждение от компилятора
const CONST1:u64 = 1000_000;	// Подчёркивание можно использовать для улучшения читаемости

// Неизменяемая переменная. Она может быть вычислена на этапе исполнения
let a = CONST1;


// Вот это делать нельзя. Константа не может приравниваться к неизменяемой переменной
// const const2 = a;


// ----------------------------------------------------------------

// Изменяемая переменная
let mut a = a + 2;

// Вторая переменная a затеняет первую переменную a (здесь это разрешено, в отличие от pony)


a += 1;

// Объявляем переменную типа u64
// Переменная, начинающаяся с "_" не будет генерировать сообщения о том, что она не используется
let _b:u64 = a;


// ----------------------------------------------------------------
// ----------------------------------------------------------------
// МАШИННЫЕ ТИПЫ и иные простые типы

// https://doc.rust-lang.ru/book/ch03-02-data-types.html

// Целые числа со знаком: i8 ... i128, isize
// Без знака u8 ... u128, usize
// Типы size - это максимальное по размеру число в процессорной архитектуре

// Десятичный	98_222
// Шестнадцатеричный	0xff
// Восьмеричный	0o77
// Бинарный	0b1111_0000
// Байтовый (только u8)	b'A'

// Тип можно указать суффиксом
let _a = 1_000_u16;
let _a = 1_00u8;	// Rust не контролирует позицию подчёркивания!!!
let _a = 0o77u8;

// Плавающая точка. По умолчанию - 64 бита.
let _x = 2.0;

// 32 бита
let _x: f32 = 3.0;

// Деление "/", вычисление остатка %

// cannot divide `{float}` by `{integer}`
// 3.0/2

// 3/2 == 1, 3.0/2.0 == 1.5, 3 % 2 == 1, 3 << 2 == 12, 16 >> 2 == 4
println!("3/2 == {}, 3.0/2.0 == {}, 3 % 2 == {}, 3 << 2 == {}, 16 >> 2 == {}", 3/2, 3.0/2.0, 3 % 2, 3 << 2, 16 >> 2);

// 5 ^ 0xA == 15, 5 | 0xA == 15, 5 & 0xA == 0
println!("5 ^ 0xA == {}, 5 | 0xA == {}, 5 & 0xA == {}", 5 ^ 0xA, 5 | 0xA, 5 & 0xA);



// Булевский тип
let _b: bool = false;



// Символ имеет размер 4-ре байта
let _c: char = '₡';

// let _c: char = 0;	- это ошибка приведения типов, в отличие от pony
let _c: char = '\u{0}';	// Скобки фигурные

// let _c: char = '\u{D800}';	это ошибка: unicode escape must not be a surrogate - то есть суррогатные символы UTF-16 здесь не прокатывают - должен быть определён целый символ UTF-32.
let _c: char = '\u{D7FF}';


// ----------------------------------------------------------------
// -------------------------------- Кортежи --------------------------------

let tup: (i32, f64, u8) = (500, 6.4, 1);
let (_x, _y, _z) = tup;

let _x = tup.0;
let _y = tup.1;
let _z = tup.2;



// -------------------------------- Массивы --------------------------------

let _a:[u8; 5] = [1, 2, 3, 4, 5];
let _v = _a[0];

// Указанный тип [u8; 5] является типом массива u8 с 5-тью элементами

// Проверки выхода за границы массива
// let _v = _a[100]; Ошибка времени компиляции: index out of bounds: the len is 5 but the index is 100

// Ошибка времени выполнения
// let index = 100;
// let _v = _a[index]; thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 100'

}
