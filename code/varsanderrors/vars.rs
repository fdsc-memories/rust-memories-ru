#![allow(non_snake_case)]


fn main()
{
// Константа. Всегда вычисляется на этапе компиляции
// Тип константы всегда указывается явно
// Константы могут быть глобальными
// Константа пишется заглавными буквами. Иначе будет предупреждение от компилятора
const CONST1:u64 = 1000_000;	// Подчёркивание можно использовать для улучшения читаемости

// Неизменяемая переменная. Она может быть вычислена на этапе исполнения
let a = CONST1;


// Вот это делать нельзя. Константа не может приравниваться к неизменяемой переменной
// const const2 = a;


// ----------------------------------------------------------------

// Изменяемая переменная
let mut a = a + 2;

// Вторая переменная a затеняет первую переменную a (здесь это разрешено, в отличие от pony)


a += 1;

// Объявляем переменную типа u64
// Переменная, начинающаяся с "_" не будет генерировать сообщения о том, что она не используется
let _b:u64 = a;


// ----------------------------------------------------------------
// ----------------------------------------------------------------
// МАШИННЫЕ ТИПЫ и иные простые типы

// https://doc.rust-lang.ru/book/ch03-02-data-types.html

// Целые числа со знаком: i8 ... i128, isize
// Без знака u8 ... u128, usize
// Типы size - это максимальное по размеру число в процессорной архитектуре

// Десятичный	98_222
// Шестнадцатеричный	0xff
// Восьмеричный	0o77
// Бинарный	0b1111_0000
// Байтовый (только u8)	b'A'

// Тип можно указать суффиксом
let _a = 1_000_u16;
let _a = 1_00u8;	// Rust не контролирует позицию подчёркивания!!!
let _a = 0o77u8;

let _a:u64 = 128;
let _b:u8  = 8;

// Так нельзя
// let _c = _a + _b; - ошибка приведения типов
// u64 реализует trait std::convert::From<u8>
let _c = _a + u64::from(_b);



// Плавающая точка. По умолчанию - 64 бита.
let _x = 2.0;

// 32 бита
let _x: f32 = 3.0;

// Деление "/", вычисление остатка %

// cannot divide `{float}` by `{integer}`
// 3.0/2

// 3/2 == 1, 3.0/2.0 == 1.5, 3 % 2 == 1, 3 << 2 == 12, 16 >> 2 == 4
println!("3/2 == {}, 3.0/2.0 == {}, 3 % 2 == {}, 3 << 2 == {}, 16 >> 2 == {}", 3/2, 3.0/2.0, 3 % 2, 3 << 2, 16 >> 2);

// 5 ^ 0xA == 15, 5 | 0xA == 15, 5 & 0xA == 0
println!("5 ^ 0xA == {}, 5 | 0xA == {}, 5 & 0xA == {}", 5 ^ 0xA, 5 | 0xA, 5 & 0xA);



// Булевский тип
let _b: bool = false;



// Символ имеет размер 4-ре байта
let _c: char = '₡';

// let _c: char = 0;	- это ошибка приведения типов, в отличие от pony
let _c: char = '\u{0}';	// Скобки фигурные

// let _c: char = '\u{D800}';	это ошибка: unicode escape must not be a surrogate - то есть суррогатные символы UTF-16 здесь не прокатывают - должен быть определён целый символ UTF-32.
let _c: char = '\u{D7FF}';


// -------------------------------------------------------------------------
// -------------------------------- Кортежи --------------------------------

let tup: (i32, f64, u8) = (500, 6.4, 1);
let (_x, _y, _z) = tup;

let _x = tup.0;
let _y = tup.1;
let _z = tup.2;


// ----------------------------------------------------------------------------------------
// ---------------------------- Стандартное управление памятью ----------------------------

memoryManagement();

}

fn memoryManagement()
{
	/*
		В Rust нет сборщика мусора. Однако, есть автоматическое управление памятью.
		Это достигается за счёт того, что участками памяти владеет только одна изменяемая ссылка
		или множество неизменяемых. Выходя за область видимости, объекты удаляются из памяти.

		Короче говоря, это что-то типа принципа "один писатель либо много читателей". Причём читатели посчитанные
	*/

	// Здесь мы создаём новую изменяемую строку в куче
	// s - это ссылка на строку
	// Компилятор всегда гарантирует,
	// что ссылка не будет удалена ранее, чем она выйдет из области видимости
	let s = String::from("Привет");

	// Если мы хотим изменять ссылку на строку, то нужно объявить её mutable
	let mut s = s;
	
	// При затенении s другая s выходит из зоны видимости. Rust может её автоматически удалить
	// Однако, Rust видит, что новая s теперь владеет тем участком памяти, которым раньше владела старая переменная s и не будет освобождать память
	// Таким образом, владение (ownership) строкой от одной переменной передаётся к другой

	// Изменили строку (она теперь по новому адресу)
	s.push_str(" всем!");

	// Выведет строку "Привет всем!"
	println!("{}", s);

	// Это не просто копирование ссылки, это "перемещение" ссылки! s теперь недействительна
	let s2 = s;
	// Здесь мы склонировали весь объект, всю строку целиком, а не только ссылку
	let s3 = s2.clone();

	// Теперь s мы не можем использовать
	// Вот так
	// println!("{}", s);
	// сделать не получится!
	// borrow of moved value - теперь строка "Привет" принадлежит ссылке s2, а ссылка s недействительна

	// s2 и s3 - это ссылки на разные строки,
	// поэтому они спокойно используются независимо друг от друга
	println!("1: {} {}", s2, s3);

	// На простых типах передача владения не происходит: значение переменной просто копируется
	// Простые типы - это те, что не требуют выделения памяти
	let u:u64 = 123456789;

	// После вызова функции также происходит передача владения ссылкой
	// s2 больше недействительная, а s4 передана во владение из getOwnerShip (например, это та же s2).
	// s3 по-прежнему действительна, т.к. передана по ссылке. Ссылка ссылается на ссылку s3, но не владеет ей. s3 "заимствована".
	let s4 = getOwnerShip(s2, &s3, u);

	// Попытка воспользоваться s2 вызовет теперь ошибку! borrow of moved value: `s2`
	// println!("{}", s2);
	// Однако простой тип по-прежнему действителен
	// Переменная s3, переданная по ссылке, также действительна.
	println!("2: {} {} {}", s3, s4, u);

	let mut s4   = s4;
	// &mut можно сделать только с mut ссылкой
	let _s4r1 = &mut s4;
	_s4r1.push_str("0");	// Добавили '0' к строке s4

	let  s4r2 = &mut s4;	// Заимствование для s4r1 ушло, пошло заимствование для s4r2

	// Если вставим вот это
	// println!("{} {} {}", _s4r1, s4r2, u);
	// то получим ошибку
	// cannot borrow `s4` as mutable more than once at a time
	// То есть вторую заимствованную изменяемую ссылку можно делать только тогда, когда первая заимствованная неизменяемая ссылка больше не будет использована
	// Короче говоря, сейчас мы уже позаимствовали s4 для s4r2, и больше _s4r1 уже не действительна

	// let s4r3 = &s4;
	// это уже не работает, т.к. есть ссылка s4r2 заимствовала s4 и нужно работать с s4r2

	let  s4r3 = & s4r2;	// Здесь нет перемещений, это неизменяемое заимствование от s4r2
	let  s4r4 = & s4r2;


	// Здесь мы можем использовать неизменяемые ссылки в любом количестве
	// но только пока не начали использовать изменяемую (заимствованную)
	// Изменяемыми ссылками мы просто сейчас владеем
	println!("3: {}", s4r2);
	// Использование s4r2 как неизменяемой не нарушает возможность использования
	// других заимствованных неизменяемых ссылок
	println!("4: {} {}", s4r3, s4r4);

	s4r2.push_str("1");	// Отдали заимствование s4r3 и s4r4
	// Вот так сделать не получится, т.к. мы уже отдали заимствование
	// println!("{} {}", s4r3, s4r4);

	// Вот это тоже нельзя :)
	// s4.push_str("0");
	// Потому что s4r2 всё ещё используется, она ещё не отдала заимствование
	// Это тоже уже нельзя, так как уже отдали заимствование
	// _s4r1.push_str("0");
	// Владение ссылкой или заимствование может быть только одно
	s4r2.push_str("2");

	// После того, как мы поработали с заимствованными ссылками, мы можем вернуться к основной переменной
	// Но ссылки будут уже не действительны
	// Только основная ссылка либо одно заимствование действительно в данный момент времени
	s4.push_str("3");
	println!("5: {}", s4);

	println!("{}", returnString((1, 2)));


	// Если нужны срезы см.
	// \code\strings\strings.rs
	// Срезы позволяют уйти от заимствования ссылок
}

// Функция забирает владение для _x,
// но не для _y, которая передаётся по ссылке (она "заимствована"),
// и не для _u, которое копируется, потому что простой тип
fn getOwnerShip(_x: String, _y: &String, _u: u64) -> String
{
	// Это делать нельзя
	// _y.push_str("aaa");
	// cannot borrow `*_y` as mutable, as it is behind a `&` reference
	// Ссылка является неизменяемой

	_x
}

// Кортеж как параметр
fn returnString((_x, _y): (u64, u64)) -> String
{
	let s = String::from("0123456789");

	// &s вернуть нельзя, т.к. s покидает область видимости и будет уничтожена
	// missing lifetime specifier

	// Вернуть s можно
	s
}
